以下の構造がある場合
● -● -● -●
     \●
  -● -● -●
        \●

幅優先探索(BFS: Breadth-First-Search)
1 -2 -4 -7
     -5
  -3 -6 -8
        -9

深さ優先探索(DFS: Deaph-First-Search)
1 -2 -3 -4
     -5
  -6 -7 -8
        -9

幅優先のアルゴリズムを考える。
始点からの距離がd である頂点は「視点からの距離が d-1 である頂点と隣接していて、かつまだ訪問していない頂点」 という考え。

キューを使う。

入力のポイント
・隣接リストE は二重配列であり、配列E[i] は頂点i に隣接する番号をもつ。

管理のポイント
・頂点が訪問済みであるかを管理する  長さNの 配列visited。 visited[i] がtrueのとき、頂点i　は訪問済みである。
・探索待ちの頂点番号を入れる キューQ

手続きのポイント
1.キューQに、始点Sを追加する。 visited[s] をTrueにする。
2.Qが空になるまで以下を繰り返す。
  Qの先頭を取り出し、iとする。
  E[i] に含まれる頂点j を列挙する。もし、jが訪問済みでなければ、visited[j] をTrueにして、Qにjを追加する。


深さ優先のアルゴリズムを考える。
始点から行き止まりになるまで探索する。行き止まりになったら、分かれ道があって他に進める先がある頂点まで、戻り、またその先を行き止まりになるまで探索していく。

再起を使う

入力のポイント
・隣接リストE は二重配列であり、配列E[i] は頂点i に隣接する番号をもつ。

管理するデータ
・各頂点が訪問済みかどうかを示す　長さNの配列visited。 visited[i]がtrueのとき、頂点i　は訪問済みである。

再起関数dfs の実装
・引数: 今見ている頂点[i]
・dfs が行う処理:
  1.頂点i について、visited[i] をTrueにする。
  2.E[i] に含まれる頂点j それぞれについて、もしj が訪問済みでなければ、dfs(j) を呼び出す。
z
手続き
dfs[s] 呼び出す。 s は始点の番号である。
zw