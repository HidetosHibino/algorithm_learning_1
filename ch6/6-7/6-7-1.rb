# 「リーダi よりも西側にいる人で、西を見ている人数」を求める方法を考える。
# これは 「0番目からi-1番目までの'W'の個数」であるので、
# Sの中の'W'の個数の累積和を求める。

# 配列            : W E W
# ｗの累積和(i-1)  : 0 1 1 2

N = gets.to_i
S = gets.chomp.split('')

sum_W = [0]

min_turn = 300000

N.times do |i|
  sum_W << if S[i] == 'W'
            sum_W[i] + 1
          else
            sum_W[i] + 0
          end
end

# 上記で　リーダーi よりも西にいて西を向いている人の人数（リーダーのいる東を向かなければならない人数）がもとまる。

# 次にリーダーi よりも東にいて東を向いている人の人数を求める必要がある。
# これを求めるには、sum_E を作成してもいいが、「東を向いている人数=全体の人数-西を向いている人数」で求めることもできる。
# i+1番目から N-1番目までのEの個数= i+1番目からN-1までの全体の数- i+1番目からN-1までのWの個数
#                             = (N-1-i) - (sum_W[N] - sum_W[i+1])

# 注意:
# i+1番目のW も含めたいので、全体数から累積和のi+1番目を引く。累積和の[i+1]は S[0]~S[i]の和
# 　　     S[0] ~ S[i]   S[i+1] ~ S[N-1]  ↓は足した結果で、例えば、W[N]はS[N-1]を含む。
# sum_w[0]  [1]  W[i+1]  W[i+2]  W[N]

N.times do |i|
  # リーダi より西側にいて、西を向いている人
  w = sum_W[i]

  # リーダiより東側にいて、東を向いている人
  e = (N - 1 - i) - (sum_W[N] - sum_W[i + 1])

  turn = w + e

  min_turn = [min_turn, turn].min
end

p min_turn
